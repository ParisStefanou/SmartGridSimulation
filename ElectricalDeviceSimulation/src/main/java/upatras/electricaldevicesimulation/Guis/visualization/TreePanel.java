/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package upatras.electricaldevicesimulation.Guis.visualization;

import upatras.automaticparallelism.execution.dag.Dag;
import upatras.automaticparallelism.tasks.DependantTask;
import upatras.automaticparallelism.tasks.Task;

import java.awt.*;
import java.util.ArrayList;

/**
 *
 * @author Paris
 */
public class TreePanel extends javax.swing.JPanel {

	/**
	 * Creates new form TreePanel
	 */
	Dag dt;

	public TreePanel(Dag dt) {
		this.dt = dt;
		initComponents();
	}

	/**
	 * This method is called from within the constructor to initialize the form.
	 * WARNING: Do NOT modify this code. The content of this method is always
	 * regenerated by the Form Editor.
	 */
	@SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents

	@Override
	public void paintComponent(Graphics g) {

		super.paintComponent(g);
		if (dt.getSize() < 10000) {

			ArrayList<Task> drawnSimulationTasks = new ArrayList<>();
			ArrayList<Point> centers = new ArrayList<>();

			for (int depth = 0; depth < dt.depthCount(); depth++) {

				ArrayList<DependantTask> SimulationTasks = dt.getTasks(depth);

				for (int k = 0; k < SimulationTasks.size(); k++) {
					DependantTask t = SimulationTasks.get(k);
					drawnSimulationTasks.add(t);
					int len = t.name.length();
					g.drawString(t.name, 100 + k * 200 - len * 2, depth * 100 + 100);

					Point p_loc = new Point(k * 200 + 100, depth * 100 + 100);

					centers.add(p_loc);

					for (int l = 0; l < t.depends_on_tasks.size(); l++) {
						DependantTask dependancy = t.depends_on_tasks.get(l);

						int dep_ind = drawnSimulationTasks.indexOf(dependancy);
						Point dep_loc = centers.get(dep_ind);
						g.setColor(Color.black);
						g.drawLine(p_loc.x, p_loc.y - 20, dep_loc.x, dep_loc.y + 10);

					}
				}

			}
		}
	}

    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
}
